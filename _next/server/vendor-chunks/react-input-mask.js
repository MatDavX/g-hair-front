/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-input-mask";
exports.ids = ["vendor-chunks/react-input-mask"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-input-mask/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-input-mask/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable import/no-unresolved */\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./lib/react-input-mask.development.js */ \"(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LW1hc2svaW5kZXguanM/MDgxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tdW5yZXNvbHZlZCAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3JlYWN0LWlucHV0LW1hc2sucHJvZHVjdGlvbi5taW4uanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9yZWFjdC1pbnB1dC1tYXNrLmRldmVsb3BtZW50LmpzXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-input-mask/lib/react-input-mask.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar invariant = _interopDefault(__webpack_require__(/*! invariant */ \"(ssr)/./node_modules/invariant/invariant.js\"));\nvar warning = _interopDefault(__webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\"));\n\nfunction _defaults2(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults2(subClass, superClass);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction defer(fn) {\n  return requestAnimationFrame(fn);\n}\nfunction cancelDefer(deferId) {\n  cancelAnimationFrame(deferId);\n}\n\nfunction setInputSelection(input, start, end) {\n  if (end === undefined) {\n    end = start;\n  }\n\n  input.setSelectionRange(start, end);\n}\nfunction getInputSelection(input) {\n  var start = input.selectionStart;\n  var end = input.selectionEnd;\n  return {\n    start: start,\n    end: end,\n    length: end - start\n  };\n}\nfunction isInputFocused(input) {\n  var inputDocument = input.ownerDocument;\n  return inputDocument.hasFocus() && inputDocument.activeElement === input;\n}\n\n// Element's window may differ from the one within React instance\n// if element rendered within iframe.\n// See https://github.com/sanniassin/react-input-mask/issues/182\nfunction getElementDocument(element) {\n  return element == null ? void 0 : element.ownerDocument;\n}\nfunction getElementWindow(element) {\n  var _getElementDocument;\n\n  return (_getElementDocument = getElementDocument(element)) == null ? void 0 : _getElementDocument.defaultView;\n}\nfunction isDOMElement(element) {\n  var elementWindow = getElementWindow(element);\n  return !!elementWindow && element instanceof elementWindow.HTMLElement;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction findLastIndex(array, predicate) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    var x = array[i];\n\n    if (predicate(x, i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nfunction repeat(string, n) {\n  if (n === void 0) {\n    n = 1;\n  }\n\n  var result = \"\";\n\n  for (var i = 0; i < n; i++) {\n    result += string;\n  }\n\n  return result;\n}\nfunction toString(value) {\n  return \"\" + value;\n}\n\nfunction useInputElement(inputRef) {\n  return React.useCallback(function () {\n    var input = inputRef.current;\n    var isDOMNode = typeof window !== \"undefined\" && isDOMElement(input); // workaround for react-test-renderer\n    // https://github.com/sanniassin/react-input-mask/issues/147\n\n    if (!input || !isDOMNode) {\n      return null;\n    }\n\n    if (input.nodeName !== \"INPUT\") {\n      input = input.querySelector(\"input\");\n    }\n\n    if (!input) {\n      throw new Error(\"react-input-mask: inputComponent doesn't contain input node\");\n    }\n\n    return input;\n  }, [inputRef]);\n}\n\nfunction useDeferLoop(callback) {\n  var deferIdRef = React.useRef(null);\n  var runLoop = React.useCallback(function () {\n    // If there are simulated focus events, runLoop could be\n    // called multiple times without blur or re-render\n    if (deferIdRef.current !== null) {\n      return;\n    }\n\n    function loop() {\n      callback();\n      deferIdRef.current = defer(loop);\n    }\n\n    loop();\n  }, [callback]);\n  var stopLoop = React.useCallback(function () {\n    cancelDefer(deferIdRef.current);\n    deferIdRef.current = null;\n  }, []);\n  React.useEffect(function () {\n    if (deferIdRef.current) {\n      stopLoop();\n      runLoop();\n    }\n  }, [runLoop, stopLoop]);\n  React.useEffect(cancelDefer, []);\n  return [runLoop, stopLoop];\n}\n\nfunction useSelection(inputRef, isMasked) {\n  var selectionRef = React.useRef({\n    start: null,\n    end: null\n  });\n  var getInputElement = useInputElement(inputRef);\n  var getSelection = React.useCallback(function () {\n    var input = getInputElement();\n    return getInputSelection(input);\n  }, [getInputElement]);\n  var getLastSelection = React.useCallback(function () {\n    return selectionRef.current;\n  }, []);\n  var setSelection = React.useCallback(function (selection) {\n    var input = getInputElement(); // Don't change selection on unfocused input\n    // because Safari sets focus on selection change (#154)\n\n    if (!input || !isInputFocused(input)) {\n      return;\n    }\n\n    setInputSelection(input, selection.start, selection.end); // Use actual selection in case the requested one was out of range\n\n    selectionRef.current = getSelection();\n  }, [getInputElement, getSelection]);\n  var selectionLoop = React.useCallback(function () {\n    selectionRef.current = getSelection();\n  }, [getSelection]);\n\n  var _useDeferLoop = useDeferLoop(selectionLoop),\n      runSelectionLoop = _useDeferLoop[0],\n      stopSelectionLoop = _useDeferLoop[1];\n\n  React.useLayoutEffect(function () {\n    if (!isMasked) {\n      return;\n    }\n\n    var input = getInputElement();\n    input.addEventListener(\"focus\", runSelectionLoop);\n    input.addEventListener(\"blur\", stopSelectionLoop);\n\n    if (isInputFocused(input)) {\n      runSelectionLoop();\n    }\n\n    return function () {\n      input.removeEventListener(\"focus\", runSelectionLoop);\n      input.removeEventListener(\"blur\", stopSelectionLoop);\n      stopSelectionLoop();\n    };\n  });\n  return {\n    getSelection: getSelection,\n    getLastSelection: getLastSelection,\n    setSelection: setSelection\n  };\n}\n\nfunction useValue(inputRef, initialValue) {\n  var getInputElement = useInputElement(inputRef);\n  var valueRef = React.useRef(initialValue);\n  var getValue = React.useCallback(function () {\n    var input = getInputElement();\n    return input.value;\n  }, [getInputElement]);\n  var getLastValue = React.useCallback(function () {\n    return valueRef.current;\n  }, []);\n  var setValue = React.useCallback(function (newValue) {\n    valueRef.current = newValue;\n    var input = getInputElement();\n\n    if (input) {\n      input.value = newValue;\n    }\n  }, [getInputElement]);\n  return {\n    getValue: getValue,\n    getLastValue: getLastValue,\n    setValue: setValue\n  };\n}\n\nfunction useInputState(initialValue, isMasked) {\n  var inputRef = React.useRef();\n\n  var _useSelection = useSelection(inputRef, isMasked),\n      getSelection = _useSelection.getSelection,\n      getLastSelection = _useSelection.getLastSelection,\n      setSelection = _useSelection.setSelection;\n\n  var _useValue = useValue(inputRef, initialValue),\n      getValue = _useValue.getValue,\n      getLastValue = _useValue.getLastValue,\n      setValue = _useValue.setValue;\n\n  function getLastInputState() {\n    return {\n      value: getLastValue(),\n      selection: getLastSelection()\n    };\n  }\n\n  function getInputState() {\n    return {\n      value: getValue(),\n      selection: getSelection()\n    };\n  }\n\n  function setInputState(_ref) {\n    var value = _ref.value,\n        selection = _ref.selection;\n    setValue(value);\n    setSelection(selection);\n  }\n\n  return {\n    inputRef: inputRef,\n    getInputState: getInputState,\n    getLastInputState: getLastInputState,\n    setInputState: setInputState\n  };\n}\nfunction usePrevious(value) {\n  var ref = React.useRef();\n  React.useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar CONTROLLED_PROPS = [\"disabled\", \"onBlur\", \"onChange\", \"onFocus\", \"onMouseDown\", \"readOnly\", \"value\"];\nvar defaultFormatChars = {\n  \"9\": /[0-9]/,\n  a: /[A-Za-z]/,\n  \"*\": /[A-Za-z0-9]/\n};\n\nfunction validateMaxLength(props) {\n   true ? warning(!props.maxLength || !props.mask, \"react-input-mask: maxLength property shouldn't be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length.\") : 0;\n}\nfunction validateMaskPlaceholder(props) {\n  var mask = props.mask,\n      maskPlaceholder = props.maskPlaceholder;\n  !(!mask || !maskPlaceholder || maskPlaceholder.length === 1 || maskPlaceholder.length === mask.length) ?  true ? invariant(false, \"react-input-mask: maskPlaceholder should either be a single character or have the same length as the mask:\\n\" + (\"mask: \" + mask + \"\\n\") + (\"maskPlaceholder: \" + maskPlaceholder)) : 0 : void 0;\n}\nfunction validateChildren(props, inputElement) {\n  var conflictProps = CONTROLLED_PROPS.filter(function (propId) {\n    return inputElement.props[propId] != null && inputElement.props[propId] !== props[propId];\n  });\n  !!conflictProps.length ?  true ? invariant(false, \"react-input-mask: the following props should be passed to the InputMask component, not to children: \" + conflictProps.join(\",\")) : 0 : void 0;\n}\n\nfunction parseMask (_ref) {\n  var mask = _ref.mask,\n      maskPlaceholder = _ref.maskPlaceholder;\n  var permanents = [];\n\n  if (!mask) {\n    return {\n      maskPlaceholder: null,\n      mask: null,\n      prefix: null,\n      lastEditablePosition: null,\n      permanents: []\n    };\n  }\n\n  if (typeof mask === \"string\") {\n    var isPermanent = false;\n    var parsedMaskString = \"\";\n    mask.split(\"\").forEach(function (character) {\n      if (!isPermanent && character === \"\\\\\") {\n        isPermanent = true;\n      } else {\n        if (isPermanent || !defaultFormatChars[character]) {\n          permanents.push(parsedMaskString.length);\n        }\n\n        parsedMaskString += character;\n        isPermanent = false;\n      }\n    });\n    mask = parsedMaskString.split(\"\").map(function (character, index) {\n      if (permanents.indexOf(index) === -1) {\n        return defaultFormatChars[character];\n      }\n\n      return character;\n    });\n  } else {\n    mask.forEach(function (character, index) {\n      if (typeof character === \"string\") {\n        permanents.push(index);\n      }\n    });\n  }\n\n  if (maskPlaceholder) {\n    if (maskPlaceholder.length === 1) {\n      maskPlaceholder = mask.map(function (character, index) {\n        if (permanents.indexOf(index) !== -1) {\n          return character;\n        }\n\n        return maskPlaceholder;\n      });\n    } else {\n      maskPlaceholder = maskPlaceholder.split(\"\");\n    }\n\n    permanents.forEach(function (position) {\n      maskPlaceholder[position] = mask[position];\n    });\n    maskPlaceholder = maskPlaceholder.join(\"\");\n  }\n\n  var prefix = permanents.filter(function (position, index) {\n    return position === index;\n  }).map(function (position) {\n    return mask[position];\n  }).join(\"\");\n  var lastEditablePosition = mask.length - 1;\n\n  while (permanents.indexOf(lastEditablePosition) !== -1) {\n    lastEditablePosition--;\n  }\n\n  return {\n    maskPlaceholder: maskPlaceholder,\n    prefix: prefix,\n    mask: mask,\n    lastEditablePosition: lastEditablePosition,\n    permanents: permanents\n  };\n}\n\n/* eslint no-use-before-define: [\"error\", { functions: false }] */\n\nvar MaskUtils = function MaskUtils(options) {\n  var _this = this;\n\n  this.isCharacterAllowedAtPosition = function (character, position) {\n    var maskPlaceholder = _this.maskOptions.maskPlaceholder;\n\n    if (_this.isCharacterFillingPosition(character, position)) {\n      return true;\n    }\n\n    if (!maskPlaceholder) {\n      return false;\n    }\n\n    return maskPlaceholder[position] === character;\n  };\n\n  this.isCharacterFillingPosition = function (character, position) {\n    var mask = _this.maskOptions.mask;\n\n    if (!character || position >= mask.length) {\n      return false;\n    }\n\n    if (!_this.isPositionEditable(position)) {\n      return mask[position] === character;\n    }\n\n    var charRule = mask[position];\n    return new RegExp(charRule).test(character);\n  };\n\n  this.isPositionEditable = function (position) {\n    var _this$maskOptions = _this.maskOptions,\n        mask = _this$maskOptions.mask,\n        permanents = _this$maskOptions.permanents;\n    return position < mask.length && permanents.indexOf(position) === -1;\n  };\n\n  this.isValueEmpty = function (value) {\n    return value.split(\"\").every(function (character, position) {\n      return !_this.isPositionEditable(position) || !_this.isCharacterFillingPosition(character, position);\n    });\n  };\n\n  this.isValueFilled = function (value) {\n    return _this.getFilledLength(value) === _this.maskOptions.lastEditablePosition + 1;\n  };\n\n  this.getDefaultSelectionForValue = function (value) {\n    var filledLength = _this.getFilledLength(value);\n\n    var cursorPosition = _this.getRightEditablePosition(filledLength);\n\n    return {\n      start: cursorPosition,\n      end: cursorPosition\n    };\n  };\n\n  this.getFilledLength = function (value) {\n    var characters = value.split(\"\");\n    var lastFilledIndex = findLastIndex(characters, function (character, position) {\n      return _this.isPositionEditable(position) && _this.isCharacterFillingPosition(character, position);\n    });\n    return lastFilledIndex + 1;\n  };\n\n  this.getStringFillingLengthAtPosition = function (string, position) {\n    var characters = string.split(\"\");\n    var insertedValue = characters.reduce(function (value, character) {\n      return _this.insertCharacterAtPosition(value, character, value.length);\n    }, repeat(\" \", position));\n    return insertedValue.length - position;\n  };\n\n  this.getLeftEditablePosition = function (position) {\n    for (var i = position; i >= 0; i--) {\n      if (_this.isPositionEditable(i)) {\n        return i;\n      }\n    }\n\n    return null;\n  };\n\n  this.getRightEditablePosition = function (position) {\n    var mask = _this.maskOptions.mask;\n\n    for (var i = position; i < mask.length; i++) {\n      if (_this.isPositionEditable(i)) {\n        return i;\n      }\n    }\n\n    return null;\n  };\n\n  this.formatValue = function (value) {\n    var _this$maskOptions2 = _this.maskOptions,\n        maskPlaceholder = _this$maskOptions2.maskPlaceholder,\n        mask = _this$maskOptions2.mask;\n\n    if (!maskPlaceholder) {\n      value = _this.insertStringAtPosition(\"\", value, 0);\n\n      while (value.length < mask.length && !_this.isPositionEditable(value.length)) {\n        value += mask[value.length];\n      }\n\n      return value;\n    }\n\n    return _this.insertStringAtPosition(maskPlaceholder, value, 0);\n  };\n\n  this.clearRange = function (value, start, len) {\n    if (!len) {\n      return value;\n    }\n\n    var end = start + len;\n    var _this$maskOptions3 = _this.maskOptions,\n        maskPlaceholder = _this$maskOptions3.maskPlaceholder,\n        mask = _this$maskOptions3.mask;\n    var clearedValue = value.split(\"\").map(function (character, i) {\n      var isEditable = _this.isPositionEditable(i);\n\n      if (!maskPlaceholder && i >= end && !isEditable) {\n        return \"\";\n      }\n\n      if (i < start || i >= end) {\n        return character;\n      }\n\n      if (!isEditable) {\n        return mask[i];\n      }\n\n      if (maskPlaceholder) {\n        return maskPlaceholder[i];\n      }\n\n      return \"\";\n    }).join(\"\");\n    return _this.formatValue(clearedValue);\n  };\n\n  this.insertCharacterAtPosition = function (value, character, position) {\n    var _this$maskOptions4 = _this.maskOptions,\n        mask = _this$maskOptions4.mask,\n        maskPlaceholder = _this$maskOptions4.maskPlaceholder;\n\n    if (position >= mask.length) {\n      return value;\n    }\n\n    var isAllowed = _this.isCharacterAllowedAtPosition(character, position);\n\n    var isEditable = _this.isPositionEditable(position);\n\n    var nextEditablePosition = _this.getRightEditablePosition(position);\n\n    var isNextPlaceholder = maskPlaceholder && nextEditablePosition ? character === maskPlaceholder[nextEditablePosition] : null;\n    var valueBefore = value.slice(0, position);\n\n    if (isAllowed || !isEditable) {\n      var insertedCharacter = isAllowed ? character : mask[position];\n      value = valueBefore + insertedCharacter;\n    }\n\n    if (!isAllowed && !isEditable && !isNextPlaceholder) {\n      value = _this.insertCharacterAtPosition(value, character, position + 1);\n    }\n\n    return value;\n  };\n\n  this.insertStringAtPosition = function (value, string, position) {\n    var _this$maskOptions5 = _this.maskOptions,\n        mask = _this$maskOptions5.mask,\n        maskPlaceholder = _this$maskOptions5.maskPlaceholder;\n\n    if (!string || position >= mask.length) {\n      return value;\n    }\n\n    var characters = string.split(\"\");\n    var isFixedLength = _this.isValueFilled(value) || !!maskPlaceholder;\n    var valueAfter = value.slice(position);\n    value = characters.reduce(function (value, character) {\n      return _this.insertCharacterAtPosition(value, character, value.length);\n    }, value.slice(0, position));\n\n    if (isFixedLength) {\n      value += valueAfter.slice(value.length - position);\n    } else if (_this.isValueFilled(value)) {\n      value += mask.slice(value.length).join(\"\");\n    } else {\n      var editableCharactersAfter = valueAfter.split(\"\").filter(function (character, i) {\n        return _this.isPositionEditable(position + i);\n      });\n      value = editableCharactersAfter.reduce(function (value, character) {\n        var nextEditablePosition = _this.getRightEditablePosition(value.length);\n\n        if (nextEditablePosition === null) {\n          return value;\n        }\n\n        if (!_this.isPositionEditable(value.length)) {\n          value += mask.slice(value.length, nextEditablePosition).join(\"\");\n        }\n\n        return _this.insertCharacterAtPosition(value, character, value.length);\n      }, value);\n    }\n\n    return value;\n  };\n\n  this.processChange = function (currentState, previousState) {\n    var _this$maskOptions6 = _this.maskOptions,\n        mask = _this$maskOptions6.mask,\n        prefix = _this$maskOptions6.prefix,\n        lastEditablePosition = _this$maskOptions6.lastEditablePosition;\n    var value = currentState.value,\n        selection = currentState.selection;\n    var previousValue = previousState.value;\n    var previousSelection = previousState.selection;\n    var newValue = value;\n    var enteredString = \"\";\n    var formattedEnteredStringLength = 0;\n    var removedLength = 0;\n    var cursorPosition = Math.min(previousSelection.start, selection.start);\n\n    if (selection.end > previousSelection.start) {\n      enteredString = newValue.slice(previousSelection.start, selection.end);\n      formattedEnteredStringLength = _this.getStringFillingLengthAtPosition(enteredString, cursorPosition);\n\n      if (!formattedEnteredStringLength) {\n        removedLength = 0;\n      } else {\n        removedLength = previousSelection.length;\n      }\n    } else if (newValue.length < previousValue.length) {\n      removedLength = previousValue.length - newValue.length;\n    }\n\n    newValue = previousValue;\n\n    if (removedLength) {\n      if (removedLength === 1 && !previousSelection.length) {\n        var deleteFromRight = previousSelection.start === selection.start;\n        cursorPosition = deleteFromRight ? _this.getRightEditablePosition(selection.start) : _this.getLeftEditablePosition(selection.start);\n      }\n\n      newValue = _this.clearRange(newValue, cursorPosition, removedLength);\n    }\n\n    newValue = _this.insertStringAtPosition(newValue, enteredString, cursorPosition);\n    cursorPosition += formattedEnteredStringLength;\n\n    if (cursorPosition >= mask.length) {\n      cursorPosition = mask.length;\n    } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {\n      cursorPosition = prefix.length;\n    } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {\n      cursorPosition = _this.getRightEditablePosition(cursorPosition);\n    }\n\n    newValue = _this.formatValue(newValue);\n    return {\n      value: newValue,\n      enteredString: enteredString,\n      selection: {\n        start: cursorPosition,\n        end: cursorPosition\n      }\n    };\n  };\n\n  this.maskOptions = parseMask(options);\n};\n\nvar InputMaskChildrenWrapper =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(InputMaskChildrenWrapper, _React$Component);\n\n  function InputMaskChildrenWrapper() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = InputMaskChildrenWrapper.prototype;\n\n  _proto.render = function render() {\n    // eslint-disable-next-line react/prop-types\n    var _this$props = this.props,\n        children = _this$props.children,\n        props = _objectWithoutPropertiesLoose(_this$props, [\"children\"]);\n\n    return React__default.cloneElement(children, props);\n  };\n\n  return InputMaskChildrenWrapper;\n}(React__default.Component);\n\nvar InputMask = React.forwardRef(function InputMask(props, forwardedRef) {\n  var alwaysShowMask = props.alwaysShowMask,\n      children = props.children,\n      mask = props.mask,\n      maskPlaceholder = props.maskPlaceholder,\n      beforeMaskedStateChange = props.beforeMaskedStateChange,\n      restProps = _objectWithoutPropertiesLoose(props, [\"alwaysShowMask\", \"children\", \"mask\", \"maskPlaceholder\", \"beforeMaskedStateChange\"]);\n\n  validateMaxLength(props);\n  validateMaskPlaceholder(props);\n  var maskUtils = new MaskUtils({\n    mask: mask,\n    maskPlaceholder: maskPlaceholder\n  });\n  var isMasked = !!mask;\n  var isEditable = !restProps.disabled && !restProps.readOnly;\n  var isControlled = props.value !== null && props.value !== undefined;\n  var previousIsMasked = usePrevious(isMasked);\n  var initialValue = toString((isControlled ? props.value : props.defaultValue) || \"\");\n\n  var _useInputState = useInputState(initialValue, isMasked),\n      inputRef = _useInputState.inputRef,\n      getInputState = _useInputState.getInputState,\n      setInputState = _useInputState.setInputState,\n      getLastInputState = _useInputState.getLastInputState;\n\n  var getInputElement = useInputElement(inputRef);\n\n  function onChange(event) {\n    var currentState = getInputState();\n    var previousState = getLastInputState();\n    var newInputState = maskUtils.processChange(currentState, previousState);\n\n    if (beforeMaskedStateChange) {\n      newInputState = beforeMaskedStateChange({\n        currentState: currentState,\n        previousState: previousState,\n        nextState: newInputState\n      });\n    }\n\n    setInputState(newInputState);\n\n    if (props.onChange) {\n      props.onChange(event);\n    }\n  }\n\n  function onFocus(event) {\n    // If autoFocus property is set, focus event fires before the ref handler gets called\n    inputRef.current = event.target;\n    var currentValue = getInputState().value;\n\n    if (isMasked && !maskUtils.isValueFilled(currentValue)) {\n      var newValue = maskUtils.formatValue(currentValue);\n      var newSelection = maskUtils.getDefaultSelectionForValue(newValue);\n      var newInputState = {\n        value: newValue,\n        selection: newSelection\n      };\n\n      if (beforeMaskedStateChange) {\n        newInputState = beforeMaskedStateChange({\n          currentState: getInputState(),\n          nextState: newInputState\n        });\n        newValue = newInputState.value;\n        newSelection = newInputState.selection;\n      }\n\n      setInputState(newInputState);\n\n      if (newValue !== currentValue && props.onChange) {\n        props.onChange(event);\n      } // Chrome resets selection after focus event,\n      // so we want to restore it later\n\n\n      defer(function () {\n        setInputState(getLastInputState());\n      });\n    }\n\n    if (props.onFocus) {\n      props.onFocus(event);\n    }\n  }\n\n  function onBlur(event) {\n    var currentValue = getInputState().value;\n    var lastValue = getLastInputState().value;\n\n    if (isMasked && !alwaysShowMask && maskUtils.isValueEmpty(lastValue)) {\n      var newValue = \"\";\n      var newInputState = {\n        value: newValue,\n        selection: {\n          start: null,\n          end: null\n        }\n      };\n\n      if (beforeMaskedStateChange) {\n        newInputState = beforeMaskedStateChange({\n          currentState: getInputState(),\n          nextState: newInputState\n        });\n        newValue = newInputState.value;\n      }\n\n      setInputState(newInputState);\n\n      if (newValue !== currentValue && props.onChange) {\n        props.onChange(event);\n      }\n    }\n\n    if (props.onBlur) {\n      props.onBlur(event);\n    }\n  } // Tiny unintentional mouse movements can break cursor\n  // position on focus, so we have to restore it in that case\n  //\n  // https://github.com/sanniassin/react-input-mask/issues/108\n\n\n  function onMouseDown(event) {\n    var input = getInputElement();\n\n    var _getInputState = getInputState(),\n        value = _getInputState.value;\n\n    var inputDocument = getElementDocument(input);\n\n    if (!isInputFocused(input) && !maskUtils.isValueFilled(value)) {\n      var mouseDownX = event.clientX;\n      var mouseDownY = event.clientY;\n      var mouseDownTime = new Date().getTime();\n\n      var mouseUpHandler = function mouseUpHandler(mouseUpEvent) {\n        inputDocument.removeEventListener(\"mouseup\", mouseUpHandler);\n\n        if (!isInputFocused(input)) {\n          return;\n        }\n\n        var deltaX = Math.abs(mouseUpEvent.clientX - mouseDownX);\n        var deltaY = Math.abs(mouseUpEvent.clientY - mouseDownY);\n        var axisDelta = Math.max(deltaX, deltaY);\n        var timeDelta = new Date().getTime() - mouseDownTime;\n\n        if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {\n          var _lastState = getLastInputState();\n\n          var newSelection = maskUtils.getDefaultSelectionForValue(_lastState.value);\n\n          var newState = _extends({}, _lastState, {\n            selection: newSelection\n          });\n\n          setInputState(newState);\n        }\n      };\n\n      inputDocument.addEventListener(\"mouseup\", mouseUpHandler);\n    }\n\n    if (props.onMouseDown) {\n      props.onMouseDown(event);\n    }\n  } // For controlled inputs we want to provide properly formatted\n  // value prop\n\n\n  if (isMasked && isControlled) {\n    var input = getInputElement();\n    var isFocused = input && isInputFocused(input);\n    var newValue = isFocused || alwaysShowMask || props.value ? maskUtils.formatValue(props.value) : props.value;\n\n    if (beforeMaskedStateChange) {\n      newValue = beforeMaskedStateChange({\n        nextState: {\n          value: newValue,\n          selection: {\n            start: null,\n            end: null\n          }\n        }\n      }).value;\n    }\n\n    setInputState(_extends({}, getLastInputState(), {\n      value: newValue\n    }));\n  }\n\n  var lastState = getLastInputState();\n  var lastSelection = lastState.selection;\n  var lastValue = lastState.value;\n  React.useLayoutEffect(function () {\n    if (!isMasked) {\n      return;\n    }\n\n    var input = getInputElement();\n    var isFocused = isInputFocused(input);\n    var previousSelection = lastSelection;\n    var currentState = getInputState();\n\n    var newInputState = _extends({}, currentState); // Update value for uncontrolled inputs to make sure\n    // it's always in sync with mask props\n\n\n    if (!isControlled) {\n      var currentValue = currentState.value;\n      var formattedValue = maskUtils.formatValue(currentValue);\n      var isValueEmpty = maskUtils.isValueEmpty(formattedValue);\n      var shouldFormatValue = !isValueEmpty || isFocused || alwaysShowMask;\n\n      if (shouldFormatValue) {\n        newInputState.value = formattedValue;\n      } else if (isValueEmpty && !isFocused) {\n        newInputState.value = \"\";\n      }\n    }\n\n    if (isFocused && !previousIsMasked) {\n      // Adjust selection if input got masked while being focused\n      newInputState.selection = maskUtils.getDefaultSelectionForValue(newInputState.value);\n    } else if (isControlled && isFocused && previousSelection) {\n      // Restore cursor position if value has changed outside change event\n      if (previousSelection.start !== null && previousSelection.end !== null) {\n        newInputState.selection = previousSelection;\n      }\n    }\n\n    if (beforeMaskedStateChange) {\n      newInputState = beforeMaskedStateChange({\n        currentState: currentState,\n        nextState: newInputState\n      });\n    }\n\n    setInputState(newInputState);\n  });\n\n  var inputProps = _extends({}, restProps, {\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onChange: isMasked && isEditable ? onChange : props.onChange,\n    onMouseDown: isMasked && isEditable ? onMouseDown : props.onMouseDown,\n    ref: function ref(_ref) {\n      inputRef.current = reactDom.findDOMNode(_ref);\n\n      if (isFunction(forwardedRef)) {\n        forwardedRef(_ref);\n      } else if (forwardedRef !== null && typeof forwardedRef === \"object\") {\n        forwardedRef.current = _ref;\n      }\n    },\n    value: isMasked && isControlled ? lastValue : props.value\n  });\n\n  if (children) {\n    validateChildren(props, children); // We wrap children into a class component to be able to find\n    // their input element using findDOMNode\n\n    return React__default.createElement(InputMaskChildrenWrapper, inputProps, children);\n  }\n\n  return React__default.createElement(\"input\", inputProps);\n});\nInputMask.displayName = \"InputMask\";\nInputMask.defaultProps = {\n  alwaysShowMask: false,\n  maskPlaceholder: \"_\"\n};\nInputMask.propTypes = {\n  alwaysShowMask: PropTypes.bool,\n  beforeMaskedStateChange: PropTypes.func,\n  children: PropTypes.element,\n  mask: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]))]),\n  maskPlaceholder: PropTypes.string,\n  onFocus: PropTypes.func,\n  onBlur: PropTypes.func,\n  onChange: PropTypes.func,\n  onMouseDown: PropTypes.func\n};\n\nmodule.exports = InputMask;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7O0FBRWhDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnSEFBVztBQUNsQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw0REFBWTtBQUNwRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBVztBQUNuRCw4QkFBOEIsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0MscUNBQXFDLGlEQUFpRCxnQkFBZ0IsaUJBQWlCLE9BQU8sbUJBQW1CLDREQUE0RCw2REFBNkQsNENBQTRDOztBQUV0VDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsS0FBcUMsK01BQStNLENBQU07QUFDNVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsS0FBcUMsMk1BQTJNLENBQWdCO0FBQzNXO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQixLQUFxQyx3SkFBd0osQ0FBZ0I7QUFDeE87O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGtCQUFrQjs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRzs7QUFFSCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbnB1dC1tYXNrL2xpYi9yZWFjdC1pbnB1dC1tYXNrLmRldmVsb3BtZW50LmpzPzM2M2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG52YXIgcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBQcm9wVHlwZXMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncHJvcC10eXBlcycpKTtcbnZhciBpbnZhcmlhbnQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaW52YXJpYW50JykpO1xudmFyIHdhcm5pbmcgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnd2FybmluZycpKTtcblxuZnVuY3Rpb24gX2RlZmF1bHRzMihvYmosIGRlZmF1bHRzKSB7IHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpOyBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHsgdmFyIGtleSA9IGtleXNbaV07IHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7IGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTsgfSB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9kZWZhdWx0czIoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmZXIoZm4pIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG59XG5mdW5jdGlvbiBjYW5jZWxEZWZlcihkZWZlcklkKSB7XG4gIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGRlZmVySWQpO1xufVxuXG5mdW5jdGlvbiBzZXRJbnB1dFNlbGVjdGlvbihpbnB1dCwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG4gIHZhciBlbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIGxlbmd0aDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRGb2N1c2VkKGlucHV0KSB7XG4gIHZhciBpbnB1dERvY3VtZW50ID0gaW5wdXQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIGlucHV0RG9jdW1lbnQuaGFzRm9jdXMoKSAmJiBpbnB1dERvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGlucHV0O1xufVxuXG4vLyBFbGVtZW50J3Mgd2luZG93IG1heSBkaWZmZXIgZnJvbSB0aGUgb25lIHdpdGhpbiBSZWFjdCBpbnN0YW5jZVxuLy8gaWYgZWxlbWVudCByZW5kZXJlZCB3aXRoaW4gaWZyYW1lLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzE4MlxuZnVuY3Rpb24gZ2V0RWxlbWVudERvY3VtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgX2dldEVsZW1lbnREb2N1bWVudDtcblxuICByZXR1cm4gKF9nZXRFbGVtZW50RG9jdW1lbnQgPSBnZXRFbGVtZW50RG9jdW1lbnQoZWxlbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xufVxuZnVuY3Rpb24gaXNET01FbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGVsZW1lbnRXaW5kb3cgPSBnZXRFbGVtZW50V2luZG93KGVsZW1lbnQpO1xuICByZXR1cm4gISFlbGVtZW50V2luZG93ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBlbGVtZW50V2luZG93LkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBhcnJheVtpXTtcblxuICAgIGlmIChwcmVkaWNhdGUoeCwgaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4pIHtcbiAgaWYgKG4gPT09IHZvaWQgMCkge1xuICAgIG4gPSAxO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBcIlwiICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZUlucHV0RWxlbWVudChpbnB1dFJlZikge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgdmFyIGlzRE9NTm9kZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNET01FbGVtZW50KGlucHV0KTsgLy8gd29ya2Fyb3VuZCBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzE0N1xuXG4gICAgaWYgKCFpbnB1dCB8fCAhaXNET01Ob2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQubm9kZU5hbWUgIT09IFwiSU5QVVRcIikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVhY3QtaW5wdXQtbWFzazogaW5wdXRDb21wb25lbnQgZG9lc24ndCBjb250YWluIGlucHV0IG5vZGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9LCBbaW5wdXRSZWZdKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJMb29wKGNhbGxiYWNrKSB7XG4gIHZhciBkZWZlcklkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgcnVuTG9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgc2ltdWxhdGVkIGZvY3VzIGV2ZW50cywgcnVuTG9vcCBjb3VsZCBiZVxuICAgIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRob3V0IGJsdXIgb3IgcmUtcmVuZGVyXG4gICAgaWYgKGRlZmVySWRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgZGVmZXJJZFJlZi5jdXJyZW50ID0gZGVmZXIobG9vcCk7XG4gICAgfVxuXG4gICAgbG9vcCgpO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdmFyIHN0b3BMb29wID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGNhbmNlbERlZmVyKGRlZmVySWRSZWYuY3VycmVudCk7XG4gICAgZGVmZXJJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZWZlcklkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHN0b3BMb29wKCk7XG4gICAgICBydW5Mb29wKCk7XG4gICAgfVxuICB9LCBbcnVuTG9vcCwgc3RvcExvb3BdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGNhbmNlbERlZmVyLCBbXSk7XG4gIHJldHVybiBbcnVuTG9vcCwgc3RvcExvb3BdO1xufVxuXG5mdW5jdGlvbiB1c2VTZWxlY3Rpb24oaW5wdXRSZWYsIGlzTWFza2VkKSB7XG4gIHZhciBzZWxlY3Rpb25SZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogbnVsbFxuICB9KTtcbiAgdmFyIGdldElucHV0RWxlbWVudCA9IHVzZUlucHV0RWxlbWVudChpbnB1dFJlZik7XG4gIHZhciBnZXRTZWxlY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIGdldElucHV0U2VsZWN0aW9uKGlucHV0KTtcbiAgfSwgW2dldElucHV0RWxlbWVudF0pO1xuICB2YXIgZ2V0TGFzdFNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgaW5wdXQgPSBnZXRJbnB1dEVsZW1lbnQoKTsgLy8gRG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBvbiB1bmZvY3VzZWQgaW5wdXRcbiAgICAvLyBiZWNhdXNlIFNhZmFyaSBzZXRzIGZvY3VzIG9uIHNlbGVjdGlvbiBjaGFuZ2UgKCMxNTQpXG5cbiAgICBpZiAoIWlucHV0IHx8ICFpc0lucHV0Rm9jdXNlZChpbnB1dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJbnB1dFNlbGVjdGlvbihpbnB1dCwgc2VsZWN0aW9uLnN0YXJ0LCBzZWxlY3Rpb24uZW5kKTsgLy8gVXNlIGFjdHVhbCBzZWxlY3Rpb24gaW4gY2FzZSB0aGUgcmVxdWVzdGVkIG9uZSB3YXMgb3V0IG9mIHJhbmdlXG5cbiAgICBzZWxlY3Rpb25SZWYuY3VycmVudCA9IGdldFNlbGVjdGlvbigpO1xuICB9LCBbZ2V0SW5wdXRFbGVtZW50LCBnZXRTZWxlY3Rpb25dKTtcbiAgdmFyIHNlbGVjdGlvbkxvb3AgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgPSBnZXRTZWxlY3Rpb24oKTtcbiAgfSwgW2dldFNlbGVjdGlvbl0pO1xuXG4gIHZhciBfdXNlRGVmZXJMb29wID0gdXNlRGVmZXJMb29wKHNlbGVjdGlvbkxvb3ApLFxuICAgICAgcnVuU2VsZWN0aW9uTG9vcCA9IF91c2VEZWZlckxvb3BbMF0sXG4gICAgICBzdG9wU2VsZWN0aW9uTG9vcCA9IF91c2VEZWZlckxvb3BbMV07XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTWFza2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHJ1blNlbGVjdGlvbkxvb3ApO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHN0b3BTZWxlY3Rpb25Mb29wKTtcblxuICAgIGlmIChpc0lucHV0Rm9jdXNlZChpbnB1dCkpIHtcbiAgICAgIHJ1blNlbGVjdGlvbkxvb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHJ1blNlbGVjdGlvbkxvb3ApO1xuICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgc3RvcFNlbGVjdGlvbkxvb3ApO1xuICAgICAgc3RvcFNlbGVjdGlvbkxvb3AoKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3Rpb246IGdldFNlbGVjdGlvbixcbiAgICBnZXRMYXN0U2VsZWN0aW9uOiBnZXRMYXN0U2VsZWN0aW9uLFxuICAgIHNldFNlbGVjdGlvbjogc2V0U2VsZWN0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVZhbHVlKGlucHV0UmVmLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGdldElucHV0RWxlbWVudCA9IHVzZUlucHV0RWxlbWVudChpbnB1dFJlZik7XG4gIHZhciB2YWx1ZVJlZiA9IFJlYWN0LnVzZVJlZihpbml0aWFsVmFsdWUpO1xuICB2YXIgZ2V0VmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIGlucHV0LnZhbHVlO1xuICB9LCBbZ2V0SW5wdXRFbGVtZW50XSk7XG4gIHZhciBnZXRMYXN0VmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZhbHVlUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgdmFsdWVSZWYuY3VycmVudCA9IG5ld1ZhbHVlO1xuICAgIHZhciBpbnB1dCA9IGdldElucHV0RWxlbWVudCgpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfSwgW2dldElucHV0RWxlbWVudF0pO1xuICByZXR1cm4ge1xuICAgIGdldFZhbHVlOiBnZXRWYWx1ZSxcbiAgICBnZXRMYXN0VmFsdWU6IGdldExhc3RWYWx1ZSxcbiAgICBzZXRWYWx1ZTogc2V0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSW5wdXRTdGF0ZShpbml0aWFsVmFsdWUsIGlzTWFza2VkKSB7XG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuXG4gIHZhciBfdXNlU2VsZWN0aW9uID0gdXNlU2VsZWN0aW9uKGlucHV0UmVmLCBpc01hc2tlZCksXG4gICAgICBnZXRTZWxlY3Rpb24gPSBfdXNlU2VsZWN0aW9uLmdldFNlbGVjdGlvbixcbiAgICAgIGdldExhc3RTZWxlY3Rpb24gPSBfdXNlU2VsZWN0aW9uLmdldExhc3RTZWxlY3Rpb24sXG4gICAgICBzZXRTZWxlY3Rpb24gPSBfdXNlU2VsZWN0aW9uLnNldFNlbGVjdGlvbjtcblxuICB2YXIgX3VzZVZhbHVlID0gdXNlVmFsdWUoaW5wdXRSZWYsIGluaXRpYWxWYWx1ZSksXG4gICAgICBnZXRWYWx1ZSA9IF91c2VWYWx1ZS5nZXRWYWx1ZSxcbiAgICAgIGdldExhc3RWYWx1ZSA9IF91c2VWYWx1ZS5nZXRMYXN0VmFsdWUsXG4gICAgICBzZXRWYWx1ZSA9IF91c2VWYWx1ZS5zZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBnZXRMYXN0SW5wdXRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldExhc3RWYWx1ZSgpLFxuICAgICAgc2VsZWN0aW9uOiBnZXRMYXN0U2VsZWN0aW9uKClcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5wdXRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldFZhbHVlKCksXG4gICAgICBzZWxlY3Rpb246IGdldFNlbGVjdGlvbigpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElucHV0U3RhdGUoX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbiA9IF9yZWYuc2VsZWN0aW9uO1xuICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5wdXRSZWY6IGlucHV0UmVmLFxuICAgIGdldElucHV0U3RhdGU6IGdldElucHV0U3RhdGUsXG4gICAgZ2V0TGFzdElucHV0U3RhdGU6IGdldExhc3RJbnB1dFN0YXRlLFxuICAgIHNldElucHV0U3RhdGU6IHNldElucHV0U3RhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlKSB7XG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgQ09OVFJPTExFRF9QUk9QUyA9IFtcImRpc2FibGVkXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkZvY3VzXCIsIFwib25Nb3VzZURvd25cIiwgXCJyZWFkT25seVwiLCBcInZhbHVlXCJdO1xudmFyIGRlZmF1bHRGb3JtYXRDaGFycyA9IHtcbiAgXCI5XCI6IC9bMC05XS8sXG4gIGE6IC9bQS1aYS16XS8sXG4gIFwiKlwiOiAvW0EtWmEtejAtOV0vXG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU1heExlbmd0aChwcm9wcykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFwcm9wcy5tYXhMZW5ndGggfHwgIXByb3BzLm1hc2ssIFwicmVhY3QtaW5wdXQtbWFzazogbWF4TGVuZ3RoIHByb3BlcnR5IHNob3VsZG4ndCBiZSBwYXNzZWQgdG8gdGhlIG1hc2tlZCBpbnB1dC4gSXQgYnJlYWtzIG1hc2tpbmcgYW5kIHVubmVjZXNzYXJ5IGJlY2F1c2UgbGVuZ3RoIGlzIGxpbWl0ZWQgYnkgdGhlIG1hc2sgbGVuZ3RoLlwiKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWFza1BsYWNlaG9sZGVyKHByb3BzKSB7XG4gIHZhciBtYXNrID0gcHJvcHMubWFzayxcbiAgICAgIG1hc2tQbGFjZWhvbGRlciA9IHByb3BzLm1hc2tQbGFjZWhvbGRlcjtcbiAgISghbWFzayB8fCAhbWFza1BsYWNlaG9sZGVyIHx8IG1hc2tQbGFjZWhvbGRlci5sZW5ndGggPT09IDEgfHwgbWFza1BsYWNlaG9sZGVyLmxlbmd0aCA9PT0gbWFzay5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcInJlYWN0LWlucHV0LW1hc2s6IG1hc2tQbGFjZWhvbGRlciBzaG91bGQgZWl0aGVyIGJlIGEgc2luZ2xlIGNoYXJhY3RlciBvciBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbWFzazpcXG5cIiArIChcIm1hc2s6IFwiICsgbWFzayArIFwiXFxuXCIpICsgKFwibWFza1BsYWNlaG9sZGVyOiBcIiArIG1hc2tQbGFjZWhvbGRlcikpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRyZW4ocHJvcHMsIGlucHV0RWxlbWVudCkge1xuICB2YXIgY29uZmxpY3RQcm9wcyA9IENPTlRST0xMRURfUFJPUFMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wSWQpIHtcbiAgICByZXR1cm4gaW5wdXRFbGVtZW50LnByb3BzW3Byb3BJZF0gIT0gbnVsbCAmJiBpbnB1dEVsZW1lbnQucHJvcHNbcHJvcElkXSAhPT0gcHJvcHNbcHJvcElkXTtcbiAgfSk7XG4gICEhY29uZmxpY3RQcm9wcy5sZW5ndGggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwicmVhY3QtaW5wdXQtbWFzazogdGhlIGZvbGxvd2luZyBwcm9wcyBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBJbnB1dE1hc2sgY29tcG9uZW50LCBub3QgdG8gY2hpbGRyZW46IFwiICsgY29uZmxpY3RQcm9wcy5qb2luKFwiLFwiKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hc2sgKF9yZWYpIHtcbiAgdmFyIG1hc2sgPSBfcmVmLm1hc2ssXG4gICAgICBtYXNrUGxhY2Vob2xkZXIgPSBfcmVmLm1hc2tQbGFjZWhvbGRlcjtcbiAgdmFyIHBlcm1hbmVudHMgPSBbXTtcblxuICBpZiAoIW1hc2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFza1BsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgbWFzazogbnVsbCxcbiAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uOiBudWxsLFxuICAgICAgcGVybWFuZW50czogW11cbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtYXNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIGlzUGVybWFuZW50ID0gZmFsc2U7XG4gICAgdmFyIHBhcnNlZE1hc2tTdHJpbmcgPSBcIlwiO1xuICAgIG1hc2suc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgICBpZiAoIWlzUGVybWFuZW50ICYmIGNoYXJhY3RlciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgaXNQZXJtYW5lbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUGVybWFuZW50IHx8ICFkZWZhdWx0Rm9ybWF0Q2hhcnNbY2hhcmFjdGVyXSkge1xuICAgICAgICAgIHBlcm1hbmVudHMucHVzaChwYXJzZWRNYXNrU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWRNYXNrU3RyaW5nICs9IGNoYXJhY3RlcjtcbiAgICAgICAgaXNQZXJtYW5lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtYXNrID0gcGFyc2VkTWFza1N0cmluZy5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKGNoYXJhY3RlciwgaW5kZXgpIHtcbiAgICAgIGlmIChwZXJtYW5lbnRzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdENoYXJzW2NoYXJhY3Rlcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFyYWN0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFzay5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyYWN0ZXIsIGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGNoYXJhY3RlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwZXJtYW5lbnRzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG1hc2tQbGFjZWhvbGRlcikge1xuICAgIGlmIChtYXNrUGxhY2Vob2xkZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICBtYXNrUGxhY2Vob2xkZXIgPSBtYXNrLm1hcChmdW5jdGlvbiAoY2hhcmFjdGVyLCBpbmRleCkge1xuICAgICAgICBpZiAocGVybWFuZW50cy5pbmRleE9mKGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hc2tQbGFjZWhvbGRlcjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXNrUGxhY2Vob2xkZXIgPSBtYXNrUGxhY2Vob2xkZXIuc3BsaXQoXCJcIik7XG4gICAgfVxuXG4gICAgcGVybWFuZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgbWFza1BsYWNlaG9sZGVyW3Bvc2l0aW9uXSA9IG1hc2tbcG9zaXRpb25dO1xuICAgIH0pO1xuICAgIG1hc2tQbGFjZWhvbGRlciA9IG1hc2tQbGFjZWhvbGRlci5qb2luKFwiXCIpO1xuICB9XG5cbiAgdmFyIHByZWZpeCA9IHBlcm1hbmVudHMuZmlsdGVyKGZ1bmN0aW9uIChwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09IGluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG1hc2tbcG9zaXRpb25dO1xuICB9KS5qb2luKFwiXCIpO1xuICB2YXIgbGFzdEVkaXRhYmxlUG9zaXRpb24gPSBtYXNrLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKHBlcm1hbmVudHMuaW5kZXhPZihsYXN0RWRpdGFibGVQb3NpdGlvbikgIT09IC0xKSB7XG4gICAgbGFzdEVkaXRhYmxlUG9zaXRpb24tLTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWFza1BsYWNlaG9sZGVyOiBtYXNrUGxhY2Vob2xkZXIsXG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgbWFzazogbWFzayxcbiAgICBsYXN0RWRpdGFibGVQb3NpdGlvbjogbGFzdEVkaXRhYmxlUG9zaXRpb24sXG4gICAgcGVybWFuZW50czogcGVybWFuZW50c1xuICB9O1xufVxuXG4vKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFtcImVycm9yXCIsIHsgZnVuY3Rpb25zOiBmYWxzZSB9XSAqL1xuXG52YXIgTWFza1V0aWxzID0gZnVuY3Rpb24gTWFza1V0aWxzKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLmlzQ2hhcmFjdGVyQWxsb3dlZEF0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2hhcmFjdGVyLCBwb3NpdGlvbikge1xuICAgIHZhciBtYXNrUGxhY2Vob2xkZXIgPSBfdGhpcy5tYXNrT3B0aW9ucy5tYXNrUGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoX3RoaXMuaXNDaGFyYWN0ZXJGaWxsaW5nUG9zaXRpb24oY2hhcmFjdGVyLCBwb3NpdGlvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbWFza1BsYWNlaG9sZGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2tQbGFjZWhvbGRlcltwb3NpdGlvbl0gPT09IGNoYXJhY3RlcjtcbiAgfTtcblxuICB0aGlzLmlzQ2hhcmFjdGVyRmlsbGluZ1Bvc2l0aW9uID0gZnVuY3Rpb24gKGNoYXJhY3RlciwgcG9zaXRpb24pIHtcbiAgICB2YXIgbWFzayA9IF90aGlzLm1hc2tPcHRpb25zLm1hc2s7XG5cbiAgICBpZiAoIWNoYXJhY3RlciB8fCBwb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuIG1hc2tbcG9zaXRpb25dID09PSBjaGFyYWN0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJSdWxlID0gbWFza1twb3NpdGlvbl07XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoY2hhclJ1bGUpLnRlc3QoY2hhcmFjdGVyKTtcbiAgfTtcblxuICB0aGlzLmlzUG9zaXRpb25FZGl0YWJsZSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBfdGhpcyRtYXNrT3B0aW9ucyA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnMubWFzayxcbiAgICAgICAgcGVybWFuZW50cyA9IF90aGlzJG1hc2tPcHRpb25zLnBlcm1hbmVudHM7XG4gICAgcmV0dXJuIHBvc2l0aW9uIDwgbWFzay5sZW5ndGggJiYgcGVybWFuZW50cy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTE7XG4gIH07XG5cbiAgdGhpcy5pc1ZhbHVlRW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCJcIikuZXZlcnkoZnVuY3Rpb24gKGNoYXJhY3RlciwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHBvc2l0aW9uKSB8fCAhX3RoaXMuaXNDaGFyYWN0ZXJGaWxsaW5nUG9zaXRpb24oY2hhcmFjdGVyLCBwb3NpdGlvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5pc1ZhbHVlRmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIF90aGlzLmdldEZpbGxlZExlbmd0aCh2YWx1ZSkgPT09IF90aGlzLm1hc2tPcHRpb25zLmxhc3RFZGl0YWJsZVBvc2l0aW9uICsgMTtcbiAgfTtcblxuICB0aGlzLmdldERlZmF1bHRTZWxlY3Rpb25Gb3JWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBmaWxsZWRMZW5ndGggPSBfdGhpcy5nZXRGaWxsZWRMZW5ndGgodmFsdWUpO1xuXG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gX3RoaXMuZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKGZpbGxlZExlbmd0aCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IGN1cnNvclBvc2l0aW9uLFxuICAgICAgZW5kOiBjdXJzb3JQb3NpdGlvblxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5nZXRGaWxsZWRMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY2hhcmFjdGVycyA9IHZhbHVlLnNwbGl0KFwiXCIpO1xuICAgIHZhciBsYXN0RmlsbGVkSW5kZXggPSBmaW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uIChjaGFyYWN0ZXIsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHBvc2l0aW9uKSAmJiBfdGhpcy5pc0NoYXJhY3RlckZpbGxpbmdQb3NpdGlvbihjaGFyYWN0ZXIsIHBvc2l0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGFzdEZpbGxlZEluZGV4ICsgMTtcbiAgfTtcblxuICB0aGlzLmdldFN0cmluZ0ZpbGxpbmdMZW5ndGhBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHN0cmluZywgcG9zaXRpb24pIHtcbiAgICB2YXIgY2hhcmFjdGVycyA9IHN0cmluZy5zcGxpdChcIlwiKTtcbiAgICB2YXIgaW5zZXJ0ZWRWYWx1ZSA9IGNoYXJhY3RlcnMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5zZXJ0Q2hhcmFjdGVyQXRQb3NpdGlvbih2YWx1ZSwgY2hhcmFjdGVyLCB2YWx1ZS5sZW5ndGgpO1xuICAgIH0sIHJlcGVhdChcIiBcIiwgcG9zaXRpb24pKTtcbiAgICByZXR1cm4gaW5zZXJ0ZWRWYWx1ZS5sZW5ndGggLSBwb3NpdGlvbjtcbiAgfTtcblxuICB0aGlzLmdldExlZnRFZGl0YWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IHBvc2l0aW9uOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKF90aGlzLmlzUG9zaXRpb25FZGl0YWJsZShpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBtYXNrID0gX3RoaXMubWFza09wdGlvbnMubWFzaztcblxuICAgIGZvciAodmFyIGkgPSBwb3NpdGlvbjsgaSA8IG1hc2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfdGhpcy5pc1Bvc2l0aW9uRWRpdGFibGUoaSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdGhpcy5mb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfdGhpcyRtYXNrT3B0aW9uczIgPSBfdGhpcy5tYXNrT3B0aW9ucyxcbiAgICAgICAgbWFza1BsYWNlaG9sZGVyID0gX3RoaXMkbWFza09wdGlvbnMyLm1hc2tQbGFjZWhvbGRlcixcbiAgICAgICAgbWFzayA9IF90aGlzJG1hc2tPcHRpb25zMi5tYXNrO1xuXG4gICAgaWYgKCFtYXNrUGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhbHVlID0gX3RoaXMuaW5zZXJ0U3RyaW5nQXRQb3NpdGlvbihcIlwiLCB2YWx1ZSwgMCk7XG5cbiAgICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBtYXNrLmxlbmd0aCAmJiAhX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFsdWUgKz0gbWFza1t2YWx1ZS5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzLmluc2VydFN0cmluZ0F0UG9zaXRpb24obWFza1BsYWNlaG9sZGVyLCB2YWx1ZSwgMCk7XG4gIH07XG5cbiAgdGhpcy5jbGVhclJhbmdlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgbGVuKSB7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gc3RhcnQgKyBsZW47XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zMyA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrUGxhY2Vob2xkZXIgPSBfdGhpcyRtYXNrT3B0aW9uczMubWFza1BsYWNlaG9sZGVyLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnMzLm1hc2s7XG4gICAgdmFyIGNsZWFyZWRWYWx1ZSA9IHZhbHVlLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoY2hhcmFjdGVyLCBpKSB7XG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IF90aGlzLmlzUG9zaXRpb25FZGl0YWJsZShpKTtcblxuICAgICAgaWYgKCFtYXNrUGxhY2Vob2xkZXIgJiYgaSA+PSBlbmQgJiYgIWlzRWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybiBtYXNrW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFza1BsYWNlaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBtYXNrUGxhY2Vob2xkZXJbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIF90aGlzLmZvcm1hdFZhbHVlKGNsZWFyZWRWYWx1ZSk7XG4gIH07XG5cbiAgdGhpcy5pbnNlcnRDaGFyYWN0ZXJBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBjaGFyYWN0ZXIsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zNCA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnM0Lm1hc2ssXG4gICAgICAgIG1hc2tQbGFjZWhvbGRlciA9IF90aGlzJG1hc2tPcHRpb25zNC5tYXNrUGxhY2Vob2xkZXI7XG5cbiAgICBpZiAocG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNBbGxvd2VkID0gX3RoaXMuaXNDaGFyYWN0ZXJBbGxvd2VkQXRQb3NpdGlvbihjaGFyYWN0ZXIsIHBvc2l0aW9uKTtcblxuICAgIHZhciBpc0VkaXRhYmxlID0gX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHBvc2l0aW9uKTtcblxuICAgIHZhciBuZXh0RWRpdGFibGVQb3NpdGlvbiA9IF90aGlzLmdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihwb3NpdGlvbik7XG5cbiAgICB2YXIgaXNOZXh0UGxhY2Vob2xkZXIgPSBtYXNrUGxhY2Vob2xkZXIgJiYgbmV4dEVkaXRhYmxlUG9zaXRpb24gPyBjaGFyYWN0ZXIgPT09IG1hc2tQbGFjZWhvbGRlcltuZXh0RWRpdGFibGVQb3NpdGlvbl0gOiBudWxsO1xuICAgIHZhciB2YWx1ZUJlZm9yZSA9IHZhbHVlLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgIGlmIChpc0FsbG93ZWQgfHwgIWlzRWRpdGFibGUpIHtcbiAgICAgIHZhciBpbnNlcnRlZENoYXJhY3RlciA9IGlzQWxsb3dlZCA/IGNoYXJhY3RlciA6IG1hc2tbcG9zaXRpb25dO1xuICAgICAgdmFsdWUgPSB2YWx1ZUJlZm9yZSArIGluc2VydGVkQ2hhcmFjdGVyO1xuICAgIH1cblxuICAgIGlmICghaXNBbGxvd2VkICYmICFpc0VkaXRhYmxlICYmICFpc05leHRQbGFjZWhvbGRlcikge1xuICAgICAgdmFsdWUgPSBfdGhpcy5pbnNlcnRDaGFyYWN0ZXJBdFBvc2l0aW9uKHZhbHVlLCBjaGFyYWN0ZXIsIHBvc2l0aW9uICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHRoaXMuaW5zZXJ0U3RyaW5nQXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpcyRtYXNrT3B0aW9uczUgPSBfdGhpcy5tYXNrT3B0aW9ucyxcbiAgICAgICAgbWFzayA9IF90aGlzJG1hc2tPcHRpb25zNS5tYXNrLFxuICAgICAgICBtYXNrUGxhY2Vob2xkZXIgPSBfdGhpcyRtYXNrT3B0aW9uczUubWFza1BsYWNlaG9sZGVyO1xuXG4gICAgaWYgKCFzdHJpbmcgfHwgcG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcmFjdGVycyA9IHN0cmluZy5zcGxpdChcIlwiKTtcbiAgICB2YXIgaXNGaXhlZExlbmd0aCA9IF90aGlzLmlzVmFsdWVGaWxsZWQodmFsdWUpIHx8ICEhbWFza1BsYWNlaG9sZGVyO1xuICAgIHZhciB2YWx1ZUFmdGVyID0gdmFsdWUuc2xpY2UocG9zaXRpb24pO1xuICAgIHZhbHVlID0gY2hhcmFjdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBfdGhpcy5pbnNlcnRDaGFyYWN0ZXJBdFBvc2l0aW9uKHZhbHVlLCBjaGFyYWN0ZXIsIHZhbHVlLmxlbmd0aCk7XG4gICAgfSwgdmFsdWUuc2xpY2UoMCwgcG9zaXRpb24pKTtcblxuICAgIGlmIChpc0ZpeGVkTGVuZ3RoKSB7XG4gICAgICB2YWx1ZSArPSB2YWx1ZUFmdGVyLnNsaWNlKHZhbHVlLmxlbmd0aCAtIHBvc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKF90aGlzLmlzVmFsdWVGaWxsZWQodmFsdWUpKSB7XG4gICAgICB2YWx1ZSArPSBtYXNrLnNsaWNlKHZhbHVlLmxlbmd0aCkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkaXRhYmxlQ2hhcmFjdGVyc0FmdGVyID0gdmFsdWVBZnRlci5zcGxpdChcIlwiKS5maWx0ZXIoZnVuY3Rpb24gKGNoYXJhY3RlciwgaSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHBvc2l0aW9uICsgaSk7XG4gICAgICB9KTtcbiAgICAgIHZhbHVlID0gZWRpdGFibGVDaGFyYWN0ZXJzQWZ0ZXIucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgY2hhcmFjdGVyKSB7XG4gICAgICAgIHZhciBuZXh0RWRpdGFibGVQb3NpdGlvbiA9IF90aGlzLmdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbih2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChuZXh0RWRpdGFibGVQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMuaXNQb3NpdGlvbkVkaXRhYmxlKHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YWx1ZSArPSBtYXNrLnNsaWNlKHZhbHVlLmxlbmd0aCwgbmV4dEVkaXRhYmxlUG9zaXRpb24pLmpvaW4oXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuaW5zZXJ0Q2hhcmFjdGVyQXRQb3NpdGlvbih2YWx1ZSwgY2hhcmFjdGVyLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgfSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB0aGlzLnByb2Nlc3NDaGFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFN0YXRlLCBwcmV2aW91c1N0YXRlKSB7XG4gICAgdmFyIF90aGlzJG1hc2tPcHRpb25zNiA9IF90aGlzLm1hc2tPcHRpb25zLFxuICAgICAgICBtYXNrID0gX3RoaXMkbWFza09wdGlvbnM2Lm1hc2ssXG4gICAgICAgIHByZWZpeCA9IF90aGlzJG1hc2tPcHRpb25zNi5wcmVmaXgsXG4gICAgICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uID0gX3RoaXMkbWFza09wdGlvbnM2Lmxhc3RFZGl0YWJsZVBvc2l0aW9uO1xuICAgIHZhciB2YWx1ZSA9IGN1cnJlbnRTdGF0ZS52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uID0gY3VycmVudFN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzU3RhdGUudmFsdWU7XG4gICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0gcHJldmlvdXNTdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgdmFyIGVudGVyZWRTdHJpbmcgPSBcIlwiO1xuICAgIHZhciBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgICB2YXIgcmVtb3ZlZExlbmd0aCA9IDA7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gTWF0aC5taW4ocHJldmlvdXNTZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uLmVuZCA+IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0KSB7XG4gICAgICBlbnRlcmVkU3RyaW5nID0gbmV3VmFsdWUuc2xpY2UocHJldmlvdXNTZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5lbmQpO1xuICAgICAgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCA9IF90aGlzLmdldFN0cmluZ0ZpbGxpbmdMZW5ndGhBdFBvc2l0aW9uKGVudGVyZWRTdHJpbmcsIGN1cnNvclBvc2l0aW9uKTtcblxuICAgICAgaWYgKCFmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgICAgIHJlbW92ZWRMZW5ndGggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlZExlbmd0aCA9IHByZXZpb3VzU2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlLmxlbmd0aCA8IHByZXZpb3VzVmFsdWUubGVuZ3RoKSB7XG4gICAgICByZW1vdmVkTGVuZ3RoID0gcHJldmlvdXNWYWx1ZS5sZW5ndGggLSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgbmV3VmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuXG4gICAgaWYgKHJlbW92ZWRMZW5ndGgpIHtcbiAgICAgIGlmIChyZW1vdmVkTGVuZ3RoID09PSAxICYmICFwcmV2aW91c1NlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGRlbGV0ZUZyb21SaWdodCA9IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ID09PSBzZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgIGN1cnNvclBvc2l0aW9uID0gZGVsZXRlRnJvbVJpZ2h0ID8gX3RoaXMuZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKHNlbGVjdGlvbi5zdGFydCkgOiBfdGhpcy5nZXRMZWZ0RWRpdGFibGVQb3NpdGlvbihzZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBuZXdWYWx1ZSA9IF90aGlzLmNsZWFyUmFuZ2UobmV3VmFsdWUsIGN1cnNvclBvc2l0aW9uLCByZW1vdmVkTGVuZ3RoKTtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IF90aGlzLmluc2VydFN0cmluZ0F0UG9zaXRpb24obmV3VmFsdWUsIGVudGVyZWRTdHJpbmcsIGN1cnNvclBvc2l0aW9uKTtcbiAgICBjdXJzb3JQb3NpdGlvbiArPSBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoO1xuXG4gICAgaWYgKGN1cnNvclBvc2l0aW9uID49IG1hc2subGVuZ3RoKSB7XG4gICAgICBjdXJzb3JQb3NpdGlvbiA9IG1hc2subGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoY3Vyc29yUG9zaXRpb24gPCBwcmVmaXgubGVuZ3RoICYmICFmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgICBjdXJzb3JQb3NpdGlvbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChjdXJzb3JQb3NpdGlvbiA+PSBwcmVmaXgubGVuZ3RoICYmIGN1cnNvclBvc2l0aW9uIDwgbGFzdEVkaXRhYmxlUG9zaXRpb24gJiYgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCkge1xuICAgICAgY3Vyc29yUG9zaXRpb24gPSBfdGhpcy5nZXRSaWdodEVkaXRhYmxlUG9zaXRpb24oY3Vyc29yUG9zaXRpb24pO1xuICAgIH1cblxuICAgIG5ld1ZhbHVlID0gX3RoaXMuZm9ybWF0VmFsdWUobmV3VmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICBlbnRlcmVkU3RyaW5nOiBlbnRlcmVkU3RyaW5nLFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBjdXJzb3JQb3NpdGlvbixcbiAgICAgICAgZW5kOiBjdXJzb3JQb3NpdGlvblxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5tYXNrT3B0aW9ucyA9IHBhcnNlTWFzayhvcHRpb25zKTtcbn07XG5cbnZhciBJbnB1dE1hc2tDaGlsZHJlbldyYXBwZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5wdXRNYXNrQ2hpbGRyZW5XcmFwcGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJbnB1dE1hc2tDaGlsZHJlbldyYXBwZXIoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElucHV0TWFza0NoaWxkcmVuV3JhcHBlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCJdKTtcblxuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHByb3BzKTtcbiAgfTtcblxuICByZXR1cm4gSW5wdXRNYXNrQ2hpbGRyZW5XcmFwcGVyO1xufShSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQpO1xuXG52YXIgSW5wdXRNYXNrID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbnB1dE1hc2socHJvcHMsIGZvcndhcmRlZFJlZikge1xuICB2YXIgYWx3YXlzU2hvd01hc2sgPSBwcm9wcy5hbHdheXNTaG93TWFzayxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBtYXNrID0gcHJvcHMubWFzayxcbiAgICAgIG1hc2tQbGFjZWhvbGRlciA9IHByb3BzLm1hc2tQbGFjZWhvbGRlcixcbiAgICAgIGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlID0gcHJvcHMuYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UsXG4gICAgICByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiYWx3YXlzU2hvd01hc2tcIiwgXCJjaGlsZHJlblwiLCBcIm1hc2tcIiwgXCJtYXNrUGxhY2Vob2xkZXJcIiwgXCJiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZVwiXSk7XG5cbiAgdmFsaWRhdGVNYXhMZW5ndGgocHJvcHMpO1xuICB2YWxpZGF0ZU1hc2tQbGFjZWhvbGRlcihwcm9wcyk7XG4gIHZhciBtYXNrVXRpbHMgPSBuZXcgTWFza1V0aWxzKHtcbiAgICBtYXNrOiBtYXNrLFxuICAgIG1hc2tQbGFjZWhvbGRlcjogbWFza1BsYWNlaG9sZGVyXG4gIH0pO1xuICB2YXIgaXNNYXNrZWQgPSAhIW1hc2s7XG4gIHZhciBpc0VkaXRhYmxlID0gIXJlc3RQcm9wcy5kaXNhYmxlZCAmJiAhcmVzdFByb3BzLnJlYWRPbmx5O1xuICB2YXIgaXNDb250cm9sbGVkID0gcHJvcHMudmFsdWUgIT09IG51bGwgJiYgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzSXNNYXNrZWQgPSB1c2VQcmV2aW91cyhpc01hc2tlZCk7XG4gIHZhciBpbml0aWFsVmFsdWUgPSB0b1N0cmluZygoaXNDb250cm9sbGVkID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUpIHx8IFwiXCIpO1xuXG4gIHZhciBfdXNlSW5wdXRTdGF0ZSA9IHVzZUlucHV0U3RhdGUoaW5pdGlhbFZhbHVlLCBpc01hc2tlZCksXG4gICAgICBpbnB1dFJlZiA9IF91c2VJbnB1dFN0YXRlLmlucHV0UmVmLFxuICAgICAgZ2V0SW5wdXRTdGF0ZSA9IF91c2VJbnB1dFN0YXRlLmdldElucHV0U3RhdGUsXG4gICAgICBzZXRJbnB1dFN0YXRlID0gX3VzZUlucHV0U3RhdGUuc2V0SW5wdXRTdGF0ZSxcbiAgICAgIGdldExhc3RJbnB1dFN0YXRlID0gX3VzZUlucHV0U3RhdGUuZ2V0TGFzdElucHV0U3RhdGU7XG5cbiAgdmFyIGdldElucHV0RWxlbWVudCA9IHVzZUlucHV0RWxlbWVudChpbnB1dFJlZik7XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gZ2V0SW5wdXRTdGF0ZSgpO1xuICAgIHZhciBwcmV2aW91c1N0YXRlID0gZ2V0TGFzdElucHV0U3RhdGUoKTtcbiAgICB2YXIgbmV3SW5wdXRTdGF0ZSA9IG1hc2tVdGlscy5wcm9jZXNzQ2hhbmdlKGN1cnJlbnRTdGF0ZSwgcHJldmlvdXNTdGF0ZSk7XG5cbiAgICBpZiAoYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG5ld0lucHV0U3RhdGUgPSBiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSh7XG4gICAgICAgIGN1cnJlbnRTdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlLFxuICAgICAgICBuZXh0U3RhdGU6IG5ld0lucHV0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldElucHV0U3RhdGUobmV3SW5wdXRTdGF0ZSk7XG5cbiAgICBpZiAocHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgLy8gSWYgYXV0b0ZvY3VzIHByb3BlcnR5IGlzIHNldCwgZm9jdXMgZXZlbnQgZmlyZXMgYmVmb3JlIHRoZSByZWYgaGFuZGxlciBnZXRzIGNhbGxlZFxuICAgIGlucHV0UmVmLmN1cnJlbnQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGdldElucHV0U3RhdGUoKS52YWx1ZTtcblxuICAgIGlmIChpc01hc2tlZCAmJiAhbWFza1V0aWxzLmlzVmFsdWVGaWxsZWQoY3VycmVudFZhbHVlKSkge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gbWFza1V0aWxzLmZvcm1hdFZhbHVlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gbWFza1V0aWxzLmdldERlZmF1bHRTZWxlY3Rpb25Gb3JWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB2YXIgbmV3SW5wdXRTdGF0ZSA9IHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgfTtcblxuICAgICAgaWYgKGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIG5ld0lucHV0U3RhdGUgPSBiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSh7XG4gICAgICAgICAgY3VycmVudFN0YXRlOiBnZXRJbnB1dFN0YXRlKCksXG4gICAgICAgICAgbmV4dFN0YXRlOiBuZXdJbnB1dFN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld0lucHV0U3RhdGUudmFsdWU7XG4gICAgICAgIG5ld1NlbGVjdGlvbiA9IG5ld0lucHV0U3RhdGUuc2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBzZXRJbnB1dFN0YXRlKG5ld0lucHV0U3RhdGUpO1xuXG4gICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnRWYWx1ZSAmJiBwcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICBwcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgICB9IC8vIENocm9tZSByZXNldHMgc2VsZWN0aW9uIGFmdGVyIGZvY3VzIGV2ZW50LFxuICAgICAgLy8gc28gd2Ugd2FudCB0byByZXN0b3JlIGl0IGxhdGVyXG5cblxuICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRJbnB1dFN0YXRlKGdldExhc3RJbnB1dFN0YXRlKCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHByb3BzLm9uRm9jdXMoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1cihldmVudCkge1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSBnZXRJbnB1dFN0YXRlKCkudmFsdWU7XG4gICAgdmFyIGxhc3RWYWx1ZSA9IGdldExhc3RJbnB1dFN0YXRlKCkudmFsdWU7XG5cbiAgICBpZiAoaXNNYXNrZWQgJiYgIWFsd2F5c1Nob3dNYXNrICYmIG1hc2tVdGlscy5pc1ZhbHVlRW1wdHkobGFzdFZhbHVlKSkge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gXCJcIjtcbiAgICAgIHZhciBuZXdJbnB1dFN0YXRlID0ge1xuICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgIGVuZDogbnVsbFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgbmV3SW5wdXRTdGF0ZSA9IGJlZm9yZU1hc2tlZFN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICBjdXJyZW50U3RhdGU6IGdldElucHV0U3RhdGUoKSxcbiAgICAgICAgICBuZXh0U3RhdGU6IG5ld0lucHV0U3RhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3SW5wdXRTdGF0ZS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0SW5wdXRTdGF0ZShuZXdJbnB1dFN0YXRlKTtcblxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjdXJyZW50VmFsdWUgJiYgcHJvcHMub25DaGFuZ2UpIHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wcy5vbkJsdXIpIHtcbiAgICAgIHByb3BzLm9uQmx1cihldmVudCk7XG4gICAgfVxuICB9IC8vIFRpbnkgdW5pbnRlbnRpb25hbCBtb3VzZSBtb3ZlbWVudHMgY2FuIGJyZWFrIGN1cnNvclxuICAvLyBwb3NpdGlvbiBvbiBmb2N1cywgc28gd2UgaGF2ZSB0byByZXN0b3JlIGl0IGluIHRoYXQgY2FzZVxuICAvL1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fubmlhc3Npbi9yZWFjdC1pbnB1dC1tYXNrL2lzc3Vlcy8xMDhcblxuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG5cbiAgICB2YXIgX2dldElucHV0U3RhdGUgPSBnZXRJbnB1dFN0YXRlKCksXG4gICAgICAgIHZhbHVlID0gX2dldElucHV0U3RhdGUudmFsdWU7XG5cbiAgICB2YXIgaW5wdXREb2N1bWVudCA9IGdldEVsZW1lbnREb2N1bWVudChpbnB1dCk7XG5cbiAgICBpZiAoIWlzSW5wdXRGb2N1c2VkKGlucHV0KSAmJiAhbWFza1V0aWxzLmlzVmFsdWVGaWxsZWQodmFsdWUpKSB7XG4gICAgICB2YXIgbW91c2VEb3duWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB2YXIgbW91c2VEb3duWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB2YXIgbW91c2VEb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcihtb3VzZVVwRXZlbnQpIHtcbiAgICAgICAgaW5wdXREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZVVwSGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFpc0lucHV0Rm9jdXNlZChpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGFYID0gTWF0aC5hYnMobW91c2VVcEV2ZW50LmNsaWVudFggLSBtb3VzZURvd25YKTtcbiAgICAgICAgdmFyIGRlbHRhWSA9IE1hdGguYWJzKG1vdXNlVXBFdmVudC5jbGllbnRZIC0gbW91c2VEb3duWSk7XG4gICAgICAgIHZhciBheGlzRGVsdGEgPSBNYXRoLm1heChkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHZhciB0aW1lRGVsdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIG1vdXNlRG93blRpbWU7XG5cbiAgICAgICAgaWYgKGF4aXNEZWx0YSA8PSAxMCAmJiB0aW1lRGVsdGEgPD0gMjAwIHx8IGF4aXNEZWx0YSA8PSA1ICYmIHRpbWVEZWx0YSA8PSAzMDApIHtcbiAgICAgICAgICB2YXIgX2xhc3RTdGF0ZSA9IGdldExhc3RJbnB1dFN0YXRlKCk7XG5cbiAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gbWFza1V0aWxzLmdldERlZmF1bHRTZWxlY3Rpb25Gb3JWYWx1ZShfbGFzdFN0YXRlLnZhbHVlKTtcblxuICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IF9leHRlbmRzKHt9LCBfbGFzdFN0YXRlLCB7XG4gICAgICAgICAgICBzZWxlY3Rpb246IG5ld1NlbGVjdGlvblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0SW5wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlucHV0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcEhhbmRsZXIpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5vbk1vdXNlRG93bikge1xuICAgICAgcHJvcHMub25Nb3VzZURvd24oZXZlbnQpO1xuICAgIH1cbiAgfSAvLyBGb3IgY29udHJvbGxlZCBpbnB1dHMgd2Ugd2FudCB0byBwcm92aWRlIHByb3Blcmx5IGZvcm1hdHRlZFxuICAvLyB2YWx1ZSBwcm9wXG5cblxuICBpZiAoaXNNYXNrZWQgJiYgaXNDb250cm9sbGVkKSB7XG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgdmFyIGlzRm9jdXNlZCA9IGlucHV0ICYmIGlzSW5wdXRGb2N1c2VkKGlucHV0KTtcbiAgICB2YXIgbmV3VmFsdWUgPSBpc0ZvY3VzZWQgfHwgYWx3YXlzU2hvd01hc2sgfHwgcHJvcHMudmFsdWUgPyBtYXNrVXRpbHMuZm9ybWF0VmFsdWUocHJvcHMudmFsdWUpIDogcHJvcHMudmFsdWU7XG5cbiAgICBpZiAoYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG5ld1ZhbHVlID0gYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2Uoe1xuICAgICAgICBuZXh0U3RhdGU6IHtcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICAgIGVuZDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkudmFsdWU7XG4gICAgfVxuXG4gICAgc2V0SW5wdXRTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0TGFzdElucHV0U3RhdGUoKSwge1xuICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIGxhc3RTdGF0ZSA9IGdldExhc3RJbnB1dFN0YXRlKCk7XG4gIHZhciBsYXN0U2VsZWN0aW9uID0gbGFzdFN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyIGxhc3RWYWx1ZSA9IGxhc3RTdGF0ZS52YWx1ZTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTWFza2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlucHV0ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgdmFyIGlzRm9jdXNlZCA9IGlzSW5wdXRGb2N1c2VkKGlucHV0KTtcbiAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSBsYXN0U2VsZWN0aW9uO1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRJbnB1dFN0YXRlKCk7XG5cbiAgICB2YXIgbmV3SW5wdXRTdGF0ZSA9IF9leHRlbmRzKHt9LCBjdXJyZW50U3RhdGUpOyAvLyBVcGRhdGUgdmFsdWUgZm9yIHVuY29udHJvbGxlZCBpbnB1dHMgdG8gbWFrZSBzdXJlXG4gICAgLy8gaXQncyBhbHdheXMgaW4gc3luYyB3aXRoIG1hc2sgcHJvcHNcblxuXG4gICAgaWYgKCFpc0NvbnRyb2xsZWQpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50U3RhdGUudmFsdWU7XG4gICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSBtYXNrVXRpbHMuZm9ybWF0VmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICAgIHZhciBpc1ZhbHVlRW1wdHkgPSBtYXNrVXRpbHMuaXNWYWx1ZUVtcHR5KGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIHZhciBzaG91bGRGb3JtYXRWYWx1ZSA9ICFpc1ZhbHVlRW1wdHkgfHwgaXNGb2N1c2VkIHx8IGFsd2F5c1Nob3dNYXNrO1xuXG4gICAgICBpZiAoc2hvdWxkRm9ybWF0VmFsdWUpIHtcbiAgICAgICAgbmV3SW5wdXRTdGF0ZS52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlRW1wdHkgJiYgIWlzRm9jdXNlZCkge1xuICAgICAgICBuZXdJbnB1dFN0YXRlLnZhbHVlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGb2N1c2VkICYmICFwcmV2aW91c0lzTWFza2VkKSB7XG4gICAgICAvLyBBZGp1c3Qgc2VsZWN0aW9uIGlmIGlucHV0IGdvdCBtYXNrZWQgd2hpbGUgYmVpbmcgZm9jdXNlZFxuICAgICAgbmV3SW5wdXRTdGF0ZS5zZWxlY3Rpb24gPSBtYXNrVXRpbHMuZ2V0RGVmYXVsdFNlbGVjdGlvbkZvclZhbHVlKG5ld0lucHV0U3RhdGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDb250cm9sbGVkICYmIGlzRm9jdXNlZCAmJiBwcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgLy8gUmVzdG9yZSBjdXJzb3IgcG9zaXRpb24gaWYgdmFsdWUgaGFzIGNoYW5nZWQgb3V0c2lkZSBjaGFuZ2UgZXZlbnRcbiAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbi5zdGFydCAhPT0gbnVsbCAmJiBwcmV2aW91c1NlbGVjdGlvbi5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgbmV3SW5wdXRTdGF0ZS5zZWxlY3Rpb24gPSBwcmV2aW91c1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlTWFza2VkU3RhdGVDaGFuZ2UpIHtcbiAgICAgIG5ld0lucHV0U3RhdGUgPSBiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZSh7XG4gICAgICAgIGN1cnJlbnRTdGF0ZTogY3VycmVudFN0YXRlLFxuICAgICAgICBuZXh0U3RhdGU6IG5ld0lucHV0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldElucHV0U3RhdGUobmV3SW5wdXRTdGF0ZSk7XG4gIH0pO1xuXG4gIHZhciBpbnB1dFByb3BzID0gX2V4dGVuZHMoe30sIHJlc3RQcm9wcywge1xuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgb25CbHVyOiBvbkJsdXIsXG4gICAgb25DaGFuZ2U6IGlzTWFza2VkICYmIGlzRWRpdGFibGUgPyBvbkNoYW5nZSA6IHByb3BzLm9uQ2hhbmdlLFxuICAgIG9uTW91c2VEb3duOiBpc01hc2tlZCAmJiBpc0VkaXRhYmxlID8gb25Nb3VzZURvd24gOiBwcm9wcy5vbk1vdXNlRG93bixcbiAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50ID0gcmVhY3REb20uZmluZERPTU5vZGUoX3JlZik7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZvcndhcmRlZFJlZikpIHtcbiAgICAgICAgZm9yd2FyZGVkUmVmKF9yZWYpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3J3YXJkZWRSZWYuY3VycmVudCA9IF9yZWY7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZTogaXNNYXNrZWQgJiYgaXNDb250cm9sbGVkID8gbGFzdFZhbHVlIDogcHJvcHMudmFsdWVcbiAgfSk7XG5cbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFsaWRhdGVDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pOyAvLyBXZSB3cmFwIGNoaWxkcmVuIGludG8gYSBjbGFzcyBjb21wb25lbnQgdG8gYmUgYWJsZSB0byBmaW5kXG4gICAgLy8gdGhlaXIgaW5wdXQgZWxlbWVudCB1c2luZyBmaW5kRE9NTm9kZVxuXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW5wdXRNYXNrQ2hpbGRyZW5XcmFwcGVyLCBpbnB1dFByb3BzLCBjaGlsZHJlbik7XG4gIH1cblxuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIGlucHV0UHJvcHMpO1xufSk7XG5JbnB1dE1hc2suZGlzcGxheU5hbWUgPSBcIklucHV0TWFza1wiO1xuSW5wdXRNYXNrLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWx3YXlzU2hvd01hc2s6IGZhbHNlLFxuICBtYXNrUGxhY2Vob2xkZXI6IFwiX1wiXG59O1xuSW5wdXRNYXNrLnByb3BUeXBlcyA9IHtcbiAgYWx3YXlzU2hvd01hc2s6IFByb3BUeXBlcy5ib29sLFxuICBiZWZvcmVNYXNrZWRTdGF0ZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgbWFzazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmluc3RhbmNlT2YoUmVnRXhwKV0pKV0pLFxuICBtYXNrUGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dE1hc2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\n");

/***/ })

};
;